<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>index - Tag - siwei.io</title>
        <link>https://siwei.io/en/tags/index/</link>
        <description>index - Tag - siwei.io</description>
        <generator>Hugo -- gohugo.io</generator><language>en</language><managingEditor>weyl.gu@gmail.com (Wey Gu)</managingEditor>
            <webMaster>weyl.gu@gmail.com (Wey Gu)</webMaster><lastBuildDate>Sun, 20 Feb 2022 16:35:53 &#43;0800</lastBuildDate><atom:link href="https://siwei.io/en/tags/index/" rel="self" type="application/rss+xml" /><item>
    <title>Nebula Index Explained</title>
    <link>https://siwei.io/en/nebula-index-explained/</link>
    <pubDate>Sun, 20 Feb 2022 16:35:53 &#43;0800</pubDate><author>
        <name>Wey Gu</name>
    </author><guid>https://siwei.io/en/nebula-index-explained/</guid>
    <description><![CDATA[<div class="featured-image">
                <img src="/featured-image.webp" referrerpolicy="no-referrer">
            </div><blockquote>
<p>Nebula Graph Native Index explained, why <code>index not found</code>? When should I use Nebula Index and full-text index?</p>
</blockquote>
<p>The term of Nebula Graph Index is quite similar to index in RDBMS, while, they are not the same. It&rsquo;s noticed when getting started with Nebula Graph, the index confused some of the users in first glance on</p>
<ul>
<li>What exactly Nebula Graph Index is.</li>
<li>When I should use it.</li>
<li>How it impacts the performance.</li>
</ul>
<p>Today I&rsquo;m gonna walk you through the index in Nebula Graph.</p>
<p>Let&rsquo;s get started!</p>
<h2 id="what-exactly-nebula-graph-index-is" class="headerLink">
    <a href="#what-exactly-nebula-graph-index-is" class="header-mark"></a>What exactly Nebula Graph Index is</h2><p>TL;DR, Nebula Graph Index is only to be used to enable pure-prop-condition queries</p>
<ul>
<li>Not for graph walking through edges.</li>
<li>It&rsquo;s an prerequisite for such query.</li>
</ul>
<h3 id="pure-prop-condition-queries" class="headerLink">
    <a href="#pure-prop-condition-queries" class="header-mark"></a>pure-prop-condition queries</h3><p>We know that in RDBMS, an INDEX is to create a duplicated sorted DATA to enable QUERY with condition filtering on the sorted data, to <strong>accelerate the query in read</strong> and involves extra writes during the write.</p>
<blockquote>
<p>Note: in RDBMS/Tabular DB, an INDEX on some columns means to create extra data that are sorted on those columns to make query with those columns' condition to be scanned faster, rather than scanning from the original table data sorted based on the key only.</p>
</blockquote>
<p>In Nebula Graph, the INDEX is to create a duplicated sorted <strong>Vertex/Edge PROP DATA</strong> to <strong>enable the part of QUERY</strong>(it&rsquo;s a must rather than accelerate it) like The following to GET data from PROP Conditions: or I call it the pure-prop-condition queries:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="o">####</span><span class="w"> </span><span class="n">Queries</span><span class="w"> </span><span class="n">relying</span><span class="w"> </span><span class="k">on</span><span class="w"> </span><span class="n">Nebula</span><span class="w"> </span><span class="n">Graph</span><span class="w"> </span><span class="k">Index</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="o">#</span><span class="w"> </span><span class="n">query</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="n">pure</span><span class="o">-</span><span class="n">prop</span><span class="o">-</span><span class="n">condition</span><span class="w"> </span><span class="n">query</span><span class="w">
</span><span class="w"></span><span class="n">LOOKUP</span><span class="w"> </span><span class="k">ON</span><span class="w"> </span><span class="n">tag1</span><span class="w"> </span><span class="k">WHERE</span><span class="w"> </span><span class="n">col1</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="k">AND</span><span class="w"> </span><span class="n">col2</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="s2">&#34;foo&#34;</span><span class="w"> </span><span class="err">\</span><span class="w">
</span><span class="w">    </span><span class="n">YIELD</span><span class="w"> </span><span class="n">tag1</span><span class="p">.</span><span class="n">col1</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">col1</span><span class="p">,</span><span class="w"> </span><span class="n">tag1</span><span class="p">.</span><span class="n">col3</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">col3</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="o">#</span><span class="w"> </span><span class="n">query</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="n">pure</span><span class="o">-</span><span class="n">prop</span><span class="o">-</span><span class="n">condition</span><span class="w"> </span><span class="n">query</span><span class="w">
</span><span class="w"></span><span class="k">MATCH</span><span class="w"> </span><span class="p">(</span><span class="n">v</span><span class="p">:</span><span class="n">player</span><span class="w"> </span><span class="err">{</span><span class="w"> </span><span class="n">name</span><span class="p">:</span><span class="w"> </span><span class="s1">&#39;Tim Duncan&#39;</span><span class="w"> </span><span class="err">}</span><span class="p">)</span><span class="c1">--&gt;(v2:player) \
</span><span class="c1"></span><span class="w">        </span><span class="k">RETURN</span><span class="w"> </span><span class="n">v2</span><span class="p">.</span><span class="n">player</span><span class="p">.</span><span class="n">name</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">Name</span><span class="p">;</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>The pure-prop-condition queries, like above nGQL lines are literally to &ldquo;Find VID/EDGE only based on given the propertiy condtions&rdquo;. On the contrary, the following, are not pure-prop-condition queries:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="o">####</span><span class="w"> </span><span class="n">Queries</span><span class="w"> </span><span class="k">not</span><span class="w"> </span><span class="n">based</span><span class="w"> </span><span class="k">on</span><span class="w"> </span><span class="n">Nebula</span><span class="w"> </span><span class="n">Graph</span><span class="w"> </span><span class="k">Index</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="o">#</span><span class="w"> </span><span class="n">query</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">walk</span><span class="w"> </span><span class="n">query</span><span class="w"> </span><span class="n">starting</span><span class="w"> </span><span class="k">from</span><span class="w"> </span><span class="n">given</span><span class="w"> </span><span class="n">vertex</span><span class="w"> </span><span class="n">VID</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;player100&#34;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">GO</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="s2">&#34;player100&#34;</span><span class="w"> </span><span class="n">OVER</span><span class="w"> </span><span class="n">follow</span><span class="w"> </span><span class="n">REVERSELY</span><span class="w"> </span><span class="err">\</span><span class="w">
</span><span class="w">        </span><span class="n">YIELD</span><span class="w"> </span><span class="n">src</span><span class="p">(</span><span class="n">edge</span><span class="p">)</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">id</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="err">\</span><span class="w">
</span><span class="w">    </span><span class="k">GO</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="err">$</span><span class="o">-</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="n">OVER</span><span class="w"> </span><span class="n">serve</span><span class="w"> </span><span class="err">\</span><span class="w">
</span><span class="w">        </span><span class="k">WHERE</span><span class="w"> </span><span class="n">properties</span><span class="p">(</span><span class="err">$</span><span class="o">^</span><span class="p">).</span><span class="n">age</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">20</span><span class="w"> </span><span class="err">\</span><span class="w">
</span><span class="w">        </span><span class="n">YIELD</span><span class="w"> </span><span class="n">properties</span><span class="p">(</span><span class="err">$</span><span class="o">^</span><span class="p">).</span><span class="n">name</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">FriendOf</span><span class="p">,</span><span class="w"> </span><span class="n">properties</span><span class="p">(</span><span class="err">$$</span><span class="p">).</span><span class="n">name</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">Team</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="o">#</span><span class="w"> </span><span class="n">query</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="n">walk</span><span class="w"> </span><span class="n">query</span><span class="w"> </span><span class="n">starting</span><span class="w"> </span><span class="k">from</span><span class="w"> </span><span class="n">given</span><span class="w"> </span><span class="n">vertex</span><span class="w"> </span><span class="n">VID</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;player101&#34;</span><span class="w"> </span><span class="k">or</span><span class="w"> </span><span class="s2">&#34;player102&#34;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">MATCH</span><span class="w"> </span><span class="p">(</span><span class="n">v</span><span class="p">:</span><span class="n">player</span><span class="w"> </span><span class="err">{</span><span class="w"> </span><span class="n">name</span><span class="p">:</span><span class="w"> </span><span class="s1">&#39;Tim Duncan&#39;</span><span class="w"> </span><span class="err">}</span><span class="p">)</span><span class="c1">--(v2) \
</span><span class="c1"></span><span class="w">        </span><span class="k">WHERE</span><span class="w"> </span><span class="n">id</span><span class="p">(</span><span class="n">v2</span><span class="p">)</span><span class="w"> </span><span class="k">IN</span><span class="w"> </span><span class="p">[</span><span class="s2">&#34;player101&#34;</span><span class="p">,</span><span class="w"> </span><span class="s2">&#34;player102&#34;</span><span class="p">]</span><span class="w"> </span><span class="err">\</span><span class="w">
</span><span class="w">        </span><span class="k">RETURN</span><span class="w"> </span><span class="n">v2</span><span class="p">.</span><span class="n">player</span><span class="p">.</span><span class="n">name</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">Name</span><span class="p">;</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>If we look into <code>query 1</code> and <code>query 3</code>, where condition on vertex on tag:player are both <code>{ name: 'Tim Duncan' }</code> though:</p>
<ul>
<li>For <code>query 3</code> , the index is not required as the query will be started from known vertex ID in <code>[&quot;player101&quot;, &quot;player102&quot;]</code> and thus:
<ul>
<li>It&rsquo;ll directly fetch vertex Data from <code>v2</code>&rsquo;s vertex IDs</li>
<li>then to GetNeighbors(): walk through edges of <code>v2</code>, GetVertices() for next hop: <code>v</code> and filter based on property: <code>name</code></li>
</ul>
</li>
<li>For <code>query 1</code> , the query has to start from <code>v</code> due to no known vertex IDs were provided:
<ul>
<li>It&rsquo;ll do IndexScan() first to find all vertices only with property condtion of <code>{ name: 'Tim Duncan' }</code></li>
<li>Then, GetNeighbors(): walk through edges of <code>v</code>, GetVertices() for next hop: <code>v2</code></li>
</ul>
</li>
</ul>
<p>Now, we could know the whole point is on <strong>whether to know the vertexID(s)</strong>. You could check their execution plan with PROFILE or EXPLAIN like the follow:</p>
<table>
<thead>
<tr>
<th><code>query 1</code>, requires/based on index(on tag: player), pure prop condition query</th>
<th><code>query 3</code>, no index required, query starting from known vertex IDs</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="why-nebula-graph-index-is-a-must-in-pure-prop-condition-queries" class="headerLink">
    <a href="#why-nebula-graph-index-is-a-must-in-pure-prop-condition-queries" class="header-mark"></a>Why Nebula Graph index is a must in pure-prop-condition queries</h3><p>It&rsquo;s because Nebula Graph stores data in a distributed and graph-oriented way, the full scan of data was condiser too expensive to be allowed(<code>index not found</code> will occur when it&rsquo;s not created in pure-prop-condition queries).</p>
<blockquote>
<p>Note: from v3.0, it&rsquo;s possible to do TopN Scan without INDEX, where the <code>LIMIT &lt;n&gt;</code> is used, this is different from the fullscan case(INDEX is a must), which will be explained later.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">MATCH (v:player { name: &#39;Tim Duncan&#39; })--&gt;(v2:player) \
        RETURN v2.player.name AS Name LIMIT 3;
</code></pre></td></tr></table>
</div>
</div></blockquote>
<h3 id="why-pure-prop-condition-queries-onlyrequiring-index" class="headerLink">
    <a href="#why-pure-prop-condition-queries-onlyrequiring-index" class="header-mark"></a>Why pure-prop-condition queries only(requiring index)</h3><p><strong>graph-queries</strong> vs <strong>pure-prop-condition queries</strong></p>
<ul>
<li>graph-queries, see <code>query 2</code> and <code>query 3</code>, are to walk through edges all the way for the given vertices</li>
<li>pure-prop-condition queries, see <code>query 0</code> and <code>query 1</code>, are to find vertex only on given prop condtions</li>
</ul>
<p>In Nebula Graph, the data is structured in a way to enable fast graph-queries, and is already indexed/sorted on vertex ID(for both vertex and edge) in raw data, where GetNeighbors() of given vertex is cheap and fast due to the locality/stored continuously(pysically linked).</p>
<p>So in summary:</p>
<blockquote>
<p>Nebula Graph Index is sorted prop data to find vertex or edge on given pure prop conditions.</p>
</blockquote>
<h2 id="facts-on-nebula-graph-index" class="headerLink">
    <a href="#facts-on-nebula-graph-index" class="header-mark"></a>Facts on Nebula Graph Index</h2><p>To understand more details/limitations/cost of Nebula, let&rsquo;s reveal more on its design and here are some facts:</p>
<ul>
<li>
<p>Index Data is stored and sharded together with Vertex Data</p>
</li>
<li>
<p>Only Left Match: It&rsquo;s RocksDB Prefix Scan under the hood</p>
</li>
<li>
<p>Cost:</p>
<ul>
<li>Write Path: Extra Data + Extra Read</li>
<li>Read Path: RBO, Fan Out, TopN Push Down</li>
</ul>
</li>
<li>
<p>Data Full Scan TopN Sample(not fullscan) is supported w/o Index</p>
<ul>
<li>
<p><code>LOOKUP ON t YIELD t.name | LIMIT 1</code></p>
</li>
<li>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">MATCH (v:player { name: &#39;Tim Duncan&#39; })--&gt;(v2:player) \
        RETURN v2.player.name AS Name LIMIT 3;
</code></pre></td></tr></table>
</div>
</div></li>
</ul>
</li>
</ul>
<p>The key info can be seen from one of my <a href="https://www.siwei.io/en/sketch-notes/" target="_blank" rel="noopener noreffer">sketch notes</a>:</p>
<p></p>
<blockquote>
<p>We should notice that only the left match is supported in pure-prop-condition queries. For queries like wildcard or reguler-expression, Full-text Index/Search is to be used, which leveraged an external elastic search integrated with nebula: please check <a href="https://docs.nebula-graph.io/3.0.0/4.deployment-and-installation/6.deploy-text-based-index/2.deploy-es/" target="_blank" rel="noopener noreffer">Nebula Graph Full text index</a> for more.</p>
</blockquote>
<p>With this sketch note, we could see</p>
<ul>
<li>
<p>Local Index Design</p>
<ul>
<li>The index is stored and shared locally together with the graph data.</li>
<li>It&rsquo;s sorting based on prop value, and the matching is underlying a rocksDB prefix scan, that&rsquo;s why only left match is supported()</li>
</ul>
</li>
<li>
<p>Write path</p>
<ul>
<li>The index enables the RDBMS-like Prop Condition Query with cost in the write path including not only the extra write, but also, random read, to ensure the data consistency.</li>
<li>Index Data write is done in a sync way</li>
</ul>
</li>
<li>
<p>Read path</p>
<ul>
<li>In pure-prop-condition queries, in GraphD, the index will be selected with Rule-based-optimization like this example, where, in a rule, the col2 to be sorted first is considered optimal with the condition: col2 equals &lsquo;foo&rsquo;.</li>
<li>After the index was chosen, index-scan request will be fanout to storageD instances, and in the case of filters like LIMIT N, it will be pushed down to the storage side to reduce data payload.
<ul>
<li>Note: not shown in the sketch but actually from v3.0, the nebula graph allows LIMIT N Sample Prop condition query like this w/o index, which is underlying pushing down the LIMIT filter to storage side.</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>Take aways:</p>
<ul>
<li>Use index only when we have to, as it&rsquo;s costly in write cases and if limit N sample is allowed and fast enough, we can use that instead, if not: use index.</li>
<li>Index is left match
<ul>
<li>composite index order matters, should be created carefully.</li>
<li>for full-text search use case, use <a href="https://docs.nebula-graph.io/3.0.0/4.deployment-and-installation/6.deploy-text-based-index/2.deploy-es/" target="_blank" rel="noopener noreffer">full-text index</a> instead.</li>
</ul>
</li>
</ul>
<h2 id="how-to-use-the-index" class="headerLink">
    <a href="#how-to-use-the-index" class="header-mark"></a>How to use the index</h2><p>We should always refer to the <a href="https://docs.nebula-graph.io/3.0.0/3.ngql-guide/14.native-index-statements/" target="_blank" rel="noopener noreffer">documentation</a>, and I just put some highlights on this here:</p>
<ul>
<li>
<p>To create an index on a tag or edge type to specify a list of props in the order that we need.</p>
<ul>
<li><code>CREATE INDEX</code></li>
</ul>
</li>
<li>
<p>If an index was created after existing data was inserted, we need to trigger an index async rebuild job, as the index data will be written in sync way only when index is created.</p>
<ul>
<li><code>REBUILD INDEX</code></li>
</ul>
</li>
<li>
<p>We can see the index status after <code>REBUILD INDEX</code> issued.</p>
<ul>
<li><code>SHOW INDEX STATUS</code></li>
</ul>
</li>
<li>
<p>Queries levering index could be LOOKUP, and with the pipeline, in most cases we will do follow-up graph-walk queries like:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="n">LOOKUP</span><span class="w"> </span><span class="k">ON</span><span class="w"> </span><span class="n">player</span><span class="w"> </span><span class="err">\</span><span class="w">
</span><span class="w">  </span><span class="k">WHERE</span><span class="w"> </span><span class="n">player</span><span class="p">.</span><span class="n">name</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="s2">&#34;Kobe Bryant&#34;</span><span class="err">\</span><span class="w">
</span><span class="w">  </span><span class="n">YIELD</span><span class="w"> </span><span class="n">id</span><span class="p">(</span><span class="n">vertex</span><span class="p">)</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">VertexID</span><span class="p">,</span><span class="w"> </span><span class="n">properties</span><span class="p">(</span><span class="n">vertex</span><span class="p">).</span><span class="n">name</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">name</span><span class="w"> </span><span class="o">|</span><span class="err">\</span><span class="w">
</span><span class="w">  </span><span class="k">GO</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="err">$</span><span class="o">-</span><span class="p">.</span><span class="n">VertexID</span><span class="w"> </span><span class="n">OVER</span><span class="w"> </span><span class="n">serve</span><span class="w"> </span><span class="err">\</span><span class="w">
</span><span class="w">  </span><span class="n">YIELD</span><span class="w"> </span><span class="err">$</span><span class="o">-</span><span class="p">.</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">properties</span><span class="p">(</span><span class="n">edge</span><span class="p">).</span><span class="n">start_year</span><span class="p">,</span><span class="w"> </span><span class="n">properties</span><span class="p">(</span><span class="n">edge</span><span class="p">).</span><span class="n">end_year</span><span class="p">,</span><span class="w"> </span><span class="n">properties</span><span class="p">(</span><span class="err">$$</span><span class="p">).</span><span class="n">name</span><span class="p">;</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>Or in MATCH query like this, under the hood, v will be searched on index and v2 will be walked by default graph data structure without involving index.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">MATCH (v:player{name:&#34;Tim Duncan&#34;})--&gt;(v2:player) \
  RETURN v2.player.name AS Name;
</code></pre></td></tr></table>
</div>
</div></li>
</ul>
<h2 id="recap" class="headerLink">
    <a href="#recap" class="header-mark"></a>Recap</h2><p>Finally, Let&rsquo;s Recap</p>
<ul>
<li>INDEX is sorting PROP DATA to find data on given PURE PROP CONDITION</li>
<li>INDEX is <strong>not</strong> for Graph Walk</li>
<li>INDEX is left match, <strong>not</strong> for full-text search</li>
<li>INDEX has cost on WRITE</li>
<li>Remember to REBUILD after CREATE INDEX on existing data</li>
</ul>
<p>Happy Graphing!</p>
<p>Feture image credit to <a href="https://unsplash.com/photos/ZiQkhI7417A" target="_blank" rel="noopener noreffer">Alina</a></p>
]]></description>
</item><item>
    <title>Nebula Index Demystified</title>
    <link>https://siwei.io/en/sketches/nebula-index-demystified/</link>
    <pubDate>Tue, 13 Jul 2021 12:04:51 &#43;0800</pubDate><author>
        <name>Wey Gu</name>
    </author><guid>https://siwei.io/en/sketches/nebula-index-demystified/</guid>
    <description><![CDATA[<div class="featured-image">
                <img src="/nebula-index-demystified.webp" referrerpolicy="no-referrer">
            </div><p></p>
<blockquote>
<p>Nebula Graph Native Index Demystified(Chinese only now, English version will be soon uploaded)</p>
</blockquote>
<ul>
<li>Index Demystified <a href="https://www.youtube.com/watch?v=fII4hAM6S60&amp;t=33s" target="_blank" rel="noopener noreffer">0:33</a></li>
<li>When should we use index? <a href="https://www.youtube.com/watch?v=fII4hAM6S60&amp;t=397s" target="_blank" rel="noopener noreffer">06:37</a></li>
<li>Index v.s. Fulltext Index <a href="https://www.youtube.com/watch?v=fII4hAM6S60&amp;t=432s" target="_blank" rel="noopener noreffer">07:12</a></li>
<li>Index Performance Impact <a href="https://www.youtube.com/watch?v=fII4hAM6S60&amp;t=483s" target="_blank" rel="noopener noreffer">08:03</a></li>
</ul>
<h2 id="bilibili" class="headerLink">
    <a href="#bilibili" class="header-mark"></a>Bilibili</h2><div class="bilibili"><iframe src="//player.bilibili.com/player.html?bvid=BV1s64y1z7sT&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"></iframe></div>

<h2 id="youtube" class="headerLink">
    <a href="#youtube" class="header-mark"></a>Youtube</h2>
<div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
  <iframe src="https://www.youtube-nocookie.com/embed/fII4hAM6S60" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" allowfullscreen title="YouTube Video"></iframe>
</div>]]></description>
</item></channel>
</rss>
